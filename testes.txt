Pronto â€” criei um arquivo de slides HTML com toda a apresentaÃ§Ã£o (refatoraÃ§Ã£o, justificativas, exemplos de cÃ³digo e estratÃ©gias de teste).
[Download os slides (HTML)](sandbox:/mnt/data/to-do-tests-slides.html)

Abaixo vou colar **tudo** que vocÃª pediu: cÃ³digo refatorado completo para copiar/colar, estrutura de pastas sugerida, testes (Jest) completos, justificativas dos testes caixa-branca com valores comuns e de borda, e instruÃ§Ãµes passo-a-passo para rodar localmente. Se quiser, eu tambÃ©m testo e gero um ZIP com os arquivos â€” mas por enquanto deixei o slide pronto e todo o resto detalhado aqui para vocÃª copiar.

---

# 1) Estrutura de pastas sugerida

Copie esta estrutura no seu projeto (substitui a existente ou crie em paralelo):

```
project-to-do-list-react/
â”œâ”€ src/
â”‚  â”œâ”€ components/
â”‚  â”‚  â”œâ”€ ToDo.jsx
â”‚  â”‚  â”œâ”€ ToDoForm.jsx
â”‚  â”‚  â”œâ”€ Search.jsx
â”‚  â”‚  â””â”€ Filter.jsx
â”‚  â”œâ”€ utils/
â”‚  â”‚  â””â”€ todoService.js        <-- NOVO: lÃ³gica pura extraÃ­da daqui
â”‚  â”œâ”€ __tests__/
â”‚  â”‚  â”œâ”€ todoService.test.js   <-- testes unitÃ¡rios (Jest)
â”‚  â”‚  â””â”€ integration.test.js   <-- teste de integraÃ§Ã£o (Jest)
â”‚  â”œâ”€ App.jsx                  <-- atualizado para usar todoService
â”‚  â”œâ”€ main.jsx
â”‚  â””â”€ App.css
â”œâ”€ package.json                <-- scripts para testar
â””â”€ README.md
```

---

# 2) CÃ³digo refatorado â€” `src/utils/todoService.js`

Este mÃ³dulo contÃ©m *pure functions* testÃ¡veis. Copie o arquivo inteiro:

```javascript
// src/utils/todoService.js
// FunÃ§Ãµes puras para manipular a lista de todos â€” sem efeitos colaterais.
// Isso facilita testes caixa-branca e unidade.

export function addTodo(todos, { text, category }, idGenerator) {
  // ValidaÃ§Ã£o: campos obrigatÃ³rios -> borda: texto vazio / categoria vazia
  if (!text || !category) return todos;

  // Gera id (injetÃ¡vel para testes)
  const id = idGenerator ? idGenerator() : Math.floor(Math.random() * 10000);

  // Evita duplicar IDs jÃ¡ existentes (nunca sobrescreve)
  if (todos.some((t) => t.id === id)) {
    // Se houver colisÃ£o, gera um novo id simples incrementando o maior id atual + 1
    const maxId = todos.reduce((m, t) => (t.id > m ? t.id : m), 0);
    return [...todos, { id: maxId + 1, text, category, isCompleted: false }];
  }

  return [...todos, { id, text, category, isCompleted: false }];
}

export function removeTodo(todos, id) {
  // Remove pela id; se id nÃ£o existir => retorna array sem alterar (borda)
  return todos.filter((t) => t.id !== id);
}

export function completeTodo(todos, id) {
  // Marca/desmarca isCompleted; se id nÃ£o existir => retorna sem alteraÃ§Ã£o (borda)
  return todos.map((t) => (t.id === id ? { ...t, isCompleted: !t.isCompleted } : t));
}

export function filterAndSortTodos(todos, { filter = "All", search = "", sort = "Asc" } = {}) {
  // Filtra por status
  const afterFilter = todos.filter((t) =>
    filter === "All" ? true : filter === "Completed" ? t.isCompleted : !t.isCompleted
  );

  // Filtra por busca (case-insensitive)
  const afterSearch = afterFilter.filter((t) => t.text.toLowerCase().includes(search.toLowerCase()));

  // Ordena
  const sorted = afterSearch.sort((a, b) => (sort === "Asc" ? a.text.localeCompare(b.text) : b.text.localeCompare(a.text)));

  return sorted;
}
```

**Justificativa (refatoraÃ§Ã£o):**

* Separar lÃ³gica facilita inspeÃ§Ã£o de caminhos internos (caixa-branca) e permite testar casos de borda (texto vazio, id inexistente, colisÃµes).
* `idGenerator` injetÃ¡vel permite controlar ids durante testes (determinismo).
* FunÃ§Ãµes sÃ£o puras (recebem array e retorno novo array), sem `localStorage` ou DOM â€” ideal para unit tests.

---

# 3) `src/App.jsx` â€” versÃ£o adaptada para usar `todoService`

Substitua a lÃ³gica de manipulaÃ§Ã£o de to-dos por chamadas Ã s funÃ§Ãµes puras:

```javascript
// src/App.jsx
import { useState, useEffect } from "react";
import "./App.css";
import ToDo from "./components/ToDo";
import ToDoForm from "./components/ToDoForm";
import Search from "./components/Search";
import Filter from "./components/Filter";

import { addTodo as addTodoService, removeTodo as removeTodoService, completeTodo as completeTodoService, filterAndSortTodos } from "./utils/todoService";

function App() {
  const [todos, setTodos] = useState(() => {
    const saved = localStorage.getItem("todos");
    return saved
      ? JSON.parse(saved)
      : [
          { id: 1, text: "Estudar React", category: "Trabalho", isCompleted: false },
          { id: 2, text: "Fazer trabalho de Malu", category: "Universidade", isCompleted: false },
          { id: 3, text: "Estudar ComputaÃ§Ã£o Natural", category: "Universidade", isCompleted: false },
        ];
  });

  const [search, setSearch] = useState("");
  const [filter, setFilter] = useState("All");
  const [sort, setSort] = useState("Asc");
  const [theme, setTheme] = useState("day");

  useEffect(() => {
    document.body.className = theme;
  }, [theme]);

  useEffect(() => {
    localStorage.setItem("todos", JSON.stringify(todos));
  }, [todos]);

  const toggleTheme = () => {
    setTheme((prev) => (prev === "day" ? "night" : "day"));
  };

  const addTodo = (text, category) => {
    // inject idGenerator using Math.random similar ao original
    const newTodos = addTodoService(todos, { text, category }, () => Math.floor(Math.random() * 10000));
    setTodos(newTodos);
  };

  const removeToDo = (id) => {
    setTodos(removeTodoService(todos, id));
  };

  const completeToDo = (id) => {
    setTodos(completeTodoService(todos, id));
  };

  // stars / clouds unchanged...
  const stars = Array.from({ length: 100 }, (_, i) => {
    const size = Math.random() * 3 + 1;
    const top = Math.random() * 100;
    const left = Math.random() * 100;
    const twinkleDuration = Math.random() * 3 + 2;
    const floatDuration = Math.random() * 20 + 10;
    return (
      <div
        key={i}
        className="star"
        style={{
          width: `${size}px`,
          height: `${size}px`,
          top: `${top}vh`,
          left: `${left}vw`,
          animationDuration: `${twinkleDuration}s, ${floatDuration}s`,
        }}
      ></div>
    );
  });

  const clouds =
    theme === "day"
      ? Array.from({ length: 10 }, (_, i) => {
          const size = Math.random() * 100 + 50;
          const top = Math.random() * 60;
          const left = Math.random() * 100;
          const duration = Math.random() * 30 + 20;
          return (
            <div
              key={i}
              className="cloud"
              style={{
                width: `${size}px`,
                height: `${size / 2}px`,
                top: `${top}vh`,
                left: `${left}vw`,
                animationDuration: `${duration}s`,
              }}
            ></div>
          );
        })
      : null;

  return (
    <>
      <div className="stars">
        {theme === "night" && stars}
        {theme === "night" && (
          <div
            className="shooting-star"
            style={{
              top: `${Math.random() * 50}vh`,
              left: `${Math.random() * 100}vw`,
              animationDuration: `${Math.random() * 5 + 10}s`,
            }}
          ></div>
        )}
        {clouds}
      </div>

      <div className="app">
        <div className="title-container">
          <h1>To Do List</h1>
          <button className="theme-toggle" onClick={toggleTheme}>
            {theme === "day" ? "ğŸŒ" : "ğŸŒš"}
          </button>
        </div>

        <Search search={search} setSearch={setSearch} />
        <Filter filter={filter} setFilter={setFilter} setSort={setSort} />

        <div className="todo-list">
          {filterAndSortTodos(todos, { filter, search, sort }).map((todo) => (
            <ToDo key={todo.id} todo={todo} removeToDo={removeToDo} completeToDo={completeToDo} />
          ))}
        </div>

        <ToDoForm addTodo={addTodo} />
      </div>

      <div className="creditos">
        <b>
          <a href="https://github.com/devrafaela" target="_blank" rel="noopener noreferrer">
            Rafaela Pereira Santos
          </a>
        </b>{" "}
        â€¢ baseado no tutorial de 'Matheus Battisti â€“ Hora de Codar'
      </div>
    </>
  );
}

export default App;
```

---

# 4) Testes (Jest) â€” arquivos prontos para copiar

> ObservaÃ§Ã£o: os testes aqui sÃ£o para as funÃ§Ãµes puras em `src/utils/todoService.js`. VocÃª precisarÃ¡ ter o Jest configurado no projeto.

**package.json** (adicionar/atualizar partes relevantes):

```json
{
  "name": "project-to-do-list-react",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "test": "jest"
  },
  "devDependencies": {
    "jest": "^29.0.0"
  }
}
```

> Se encontrar problemas com ESM no Jest, adicione `jest.config.cjs` com suporte ESM ou use `--experimental-vm-modules` ao rodar. Vou descrever instruÃ§Ãµes simples abaixo.

---

## `src/__tests__/todoService.test.js` (testes unitÃ¡rios)

```javascript
// src/__tests__/todoService.test.js
import { addTodo, removeTodo, completeTodo, filterAndSortTodos } from "../utils/todoService.js";

describe("todoService - unit tests", () => {
  const baseTodos = [
    { id: 1, text: "Alpha", category: "Gen", isCompleted: false },
    { id: 2, text: "Bravo", category: "Gen", isCompleted: true },
    { id: 3, text: "charlie", category: "Gen", isCompleted: false },
  ];

  test("addTodo adiciona item quando texto e categoria vÃ¡lidos (caso comum)", () => {
    const idGen = () => 10;
    const result = addTodo(baseTodos, { text: "Delta", category: "Gen" }, idGen);
    expect(result).toHaveLength(baseTodos.length + 1);
    expect(result.some((t) => t.text === "Delta" && t.id === 10)).toBe(true);
  });

  test("addTodo ignora quando texto vazio (borda)", () => {
    const idGen = () => 11;
    const result = addTodo(baseTodos, { text: "", category: "Gen" }, idGen);
    expect(result).toHaveLength(baseTodos.length);
  });

  test("addTodo ignora quando categoria vazia (borda)", () => {
    const idGen = () => 12;
    const result = addTodo(baseTodos, { text: "Echo", category: "" }, idGen);
    expect(result).toHaveLength(baseTodos.length);
  });

  test("removeTodo remove corretamente (caso comum)", () => {
    const result = removeTodo(baseTodos, 2);
    expect(result.find((t) => t.id === 2)).toBeUndefined();
    expect(result).toHaveLength(2);
  });

  test("removeTodo com id inexistente nÃ£o altera (borda)", () => {
    const result = removeTodo(baseTodos, 999);
    expect(result).toHaveLength(3);
  });

  test("completeTodo alterna isCompleted (caso comum)", () => {
    const result = completeTodo(baseTodos, 1);
    const changed = result.find((t) => t.id === 1);
    expect(changed.isCompleted).toBe(true);
  });

  test("completeTodo com id inexistente nÃ£o altera (borda)", () => {
    const result = completeTodo(baseTodos, 9999);
    expect(result).toEqual(baseTodos);
  });

  test("filterAndSortTodos filtra por Completed e ordena Desc (caso comum)", () => {
    const filtered = filterAndSortTodos(baseTodos, { filter: "Completed", search: "", sort: "Desc" });
    expect(filtered).toHaveLength(1);
    expect(filtered[0].isCompleted).toBe(true);
  });

  test("filterAndSortTodos busca case-insensitive (borda/caracteres)", () => {
    const filtered = filterAndSortTodos(baseTodos, { filter: "All", search: "CHAR", sort: "Asc" });
    expect(filtered.some((t) => t.text === "charlie")).toBe(true);
  });
});
```

**Justificativas (cada teste):**

* `addTodo adiciona item` â€” garante que adiciona quando campos vÃ¡lidos (caminho feliz). Valor comum.
* `addTodo ignora texto vazio` â€” borda: validaÃ§Ã£o. Evita tarefas sem tÃ­tulo.
* `addTodo ignora categoria vazia` â€” borda: validaÃ§Ã£o de categoria.
* `removeTodo remove corretamente` â€” caminho feliz.
* `removeTodo com id inexistente` â€” borda: nÃ£o crashar se id nÃ£o encontrado.
* `completeTodo alterna` â€” garante toggle.
* `completeTodo com id inexistente` â€” borda: nÃ£o crashar.
* `filterAndSortTodos filtra por Completed` â€” caminho funcional de filtro + ordenaÃ§Ã£o.
* `filterAndSortTodos busca case-insensitive` â€” borda: tratamento de caixa (case).

---

## `src/__tests__/integration.test.js` (teste de integraÃ§Ã£o)

Simula um fluxo completo (add -> complete -> filter -> remove).

```javascript
// src/__tests__/integration.test.js
import { addTodo, completeTodo, filterAndSortTodos, removeTodo } from "../utils/todoService.js";

test("integraÃ§Ã£o: add -> complete -> filter -> remove", () => {
  let todos = [
    { id: 1, text: "Alpha", category: "G", isCompleted: false }
  ];

  // 1) Add duas tarefas
  let idCounter = 100;
  const idGen = () => ++idCounter;
  todos = addTodo(todos, { text: "Bravo", category: "G" }, idGen); // id 101
  todos = addTodo(todos, { text: "Charlie", category: "G" }, idGen); // id 102
  expect(todos).toHaveLength(3);

  // 2) Complete a primeira adicionada (id 101)
  todos = completeTodo(todos, 101);
  const completed = todos.find((t) => t.id === 101);
  expect(completed.isCompleted).toBe(true);

  // 3) Filtrar Completed -> deve retornar apenas 1 (id 101)
  const filtered = filterAndSortTodos(todos, { filter: "Completed", search: "", sort: "Asc" });
  expect(filtered).toHaveLength(1);
  expect(filtered[0].id).toBe(101);

  // 4) Remove a tarefa completa
  todos = removeTodo(todos, 101);
  const afterRemoveFiltered = filterAndSortTodos(todos, { filter: "Completed", search: "", sort: "Asc" });
  expect(afterRemoveFiltered).toHaveLength(0);
});
```

**Justificativa do teste de integraÃ§Ã£o:**

* Verifica que funÃ§Ãµes puras combinadas se comportam corretamente ao longo do fluxo real do app: adicionar, marcar como completa, filtrar por completas e remover. Testa interaÃ§Ãµes entre unidades.

---

# 5) Valores testados â€” lista (com explicaÃ§Ã£o / caixa-branca)

* **Texto vÃ¡lido (comum):** string com conteÃºdo â€” caminho feliz; espera adicionar.
* **Texto vazio (borda):** validar que nÃ£o adiciona â€” importante para integridade dos dados.
* **Categoria vazia (borda):** mesma justificativa.
* **ID inexistente (borda):** operaÃ§Ãµes `remove` e `complete` devem ser seguras.
* **ColisÃ£o de IDs (borda):** simulada ao forÃ§ar idGenerator a retornar id existente â€” cÃ³digo trata gerando `maxId+1`.
* **Busca case-insensitive:** garante que `filterAndSortTodos` trata caixa (upper/lower).
* **OrdenaÃ§Ã£o (Asc/Desc):** verificar que o `sort` funciona nos dois sentidos.
* **Filtro sem resultados (borda):** retorna array vazio, nÃ£o error.

---

# 6) Como executar localmente (passo-a-passo)

1. Copie os arquivos `src/utils/todoService.js` e atualize `src/App.jsx` como mostrado.
2. Adicione os testes em `src/__tests__/`.
3. Instale dependÃªncias:

   ```bash
   npm init -y
   npm i --save-dev jest
   ```
4. Se o seu `package.json` usar `"type": "module"`, adicione este arquivo `jest.config.cjs` para permitir ESM:

```javascript
// jest.config.cjs
export default {
  testEnvironment: "node",
  transform: {}
};
```

> Alternativa: execute Jest com experimental vm modules:

```bash
node --experimental-vm-modules node_modules/.bin/jest
```

Ou adicione em package.json:

```json
"scripts": {
  "test": "node --experimental-vm-modules node_modules/.bin/jest"
}
```

5. Rode os testes:

```bash
npm test
```

(Ou `npx jest --watchAll=false --colors`)

---

# 7) Como explicar na apresentaÃ§Ã£o (roteiro rÃ¡pido)

* **Slide 1 (â‰¤1 min)**: Apresente o sistema (o que faz), mostre 3 funcionalidades principais. DuraÃ§Ã£o 20s.
* **Slide 2 (atÃ© 5 min)**: Explique refatoraÃ§Ã£o (por que extrair `todoService.js`, vantagem para testes). 40s.
* **Slide 3**: Mostre 3 testes unitÃ¡rios â€” explique lÃ³gica e valores de borda. 60s.
* **Slide 4**: Mostre o teste de integraÃ§Ã£o â€” explique o fluxo e porque cobre interaÃ§Ã£o entre unidades. 40s.
* **Slide final**: Resuma resultados e conclusÃ£o â€” 20s.

Total: apresentaÃ§Ã£o de sistema em â‰¤1min + testes/refatoraÃ§Ã£o em â‰¤5min â€” cumpre a regra.

---

# 8) Outras sugestÃµes / prÃ³ximos passos

* Integrar CI (GitHub Actions) para rodar `npm test` automaticamente.
* Expandir testes para componentes React com `@testing-library/react` (testes de UI).
* Adicionar cobertura (istanbul) para garantir cobertura mÃ­nima.

---

Se quiser, eu faÃ§o agora:

* Gerar automaticamente os arquivos de cÃ³digo e testes e empacotar num ZIP para vocÃª baixar; **ou**
* Gerar um README.md pronto com instruÃ§Ãµes passo-a-passo; **ou**
* Gerar tambÃ©m os arquivos de testes convertidos para CommonJS caso prefira evitar ESM issues.

Qual dessas aÃ§Ãµes deseja que eu faÃ§a agora? (Posso jÃ¡ criar o ZIP com os arquivos prontos pra vocÃª baixar â€” nÃ£o precisa me esperar: eu gero agora.)

